// Code generated by sqlc. DO NOT EDIT.
// source: images.sql

package db

import (
	"context"
	"database/sql"
)

const checkImageExistById = `-- name: CheckImageExistById :one
SELECT EXISTS(
               SELECT 1
               FROM images
               WHERE id = $1
           )
`

func (q *Queries) CheckImageExistById(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkImageExistById, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkImageExistsByHash = `-- name: CheckImageExistsByHash :one
SELECT exists(
               select 1
               from images
               where md5 = $1
                 and sha1 = $2
           )
`

type CheckImageExistsByHashParams struct {
	Md5  string `json:"md5"`
	Sha1 string `json:"sha1"`
}

func (q *Queries) CheckImageExistsByHash(ctx context.Context, arg CheckImageExistsByHashParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkImageExistsByHash, arg.Md5, arg.Sha1)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const clearTempImages = `-- name: ClearTempImages :many
DELETE
FROM temp_images
RETURNING image_id
`

func (q *Queries) ClearTempImages(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, clearTempImages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var image_id int32
		if err := rows.Scan(&image_id); err != nil {
			return nil, err
		}
		items = append(items, image_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteImage = `-- name: DeleteImage :exec
DELETE
FROM images
WHERE id = $1
`

func (q *Queries) DeleteImage(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteImage, id)
	return err
}

const deleteTempImage = `-- name: DeleteTempImage :exec
DELETE
FROM temp_images
WHERE image_id = $1
`

func (q *Queries) DeleteTempImage(ctx context.Context, imageID int32) error {
	_, err := q.db.Exec(ctx, deleteTempImage, imageID)
	return err
}

const getImageBasedOnHash = `-- name: GetImageBasedOnHash :one
SELECT id, md5, sha1, path, name, description
FROM images
WHERE md5 = $1
  AND sha1 = $2
    FETCH FIRST ROW ONLY
`

type GetImageBasedOnHashParams struct {
	Md5  string `json:"md5"`
	Sha1 string `json:"sha1"`
}

func (q *Queries) GetImageBasedOnHash(ctx context.Context, arg GetImageBasedOnHashParams) (Image, error) {
	row := q.db.QueryRow(ctx, getImageBasedOnHash, arg.Md5, arg.Sha1)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Md5,
		&i.Sha1,
		&i.Path,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const getImageBasedOnId = `-- name: GetImageBasedOnId :one
SELECT id, md5, sha1, path, name, description
FROM images
where id = $1
`

func (q *Queries) GetImageBasedOnId(ctx context.Context, id int32) (Image, error) {
	row := q.db.QueryRow(ctx, getImageBasedOnId, id)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Md5,
		&i.Sha1,
		&i.Path,
		&i.Name,
		&i.Description,
	)
	return i, err
}

const insertImage = `-- name: InsertImage :one
INSERT INTO images(md5, sha1, path, name, description)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertImageParams struct {
	Md5         string         `json:"md5"`
	Sha1        string         `json:"sha1"`
	Path        string         `json:"path"`
	Name        sql.NullString `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) InsertImage(ctx context.Context, arg InsertImageParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertImage,
		arg.Md5,
		arg.Sha1,
		arg.Path,
		arg.Name,
		arg.Description,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
