// Code generated by sqlc. DO NOT EDIT.
// source: comments.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addComment = `-- name: AddComment :exec
INSERT INTO book_comments(user_id, book_group_id, book_chapter_id, content)
VALUES ($1, $2, $3, $4)
`

type AddCommentParams struct {
	UserID        int32         `json:"userID"`
	BookGroupID   int32         `json:"bookGroupID"`
	BookChapterID sql.NullInt32 `json:"bookChapterID"`
	Content       string        `json:"content"`
}

func (q *Queries) AddComment(ctx context.Context, arg AddCommentParams) error {
	_, err := q.db.Exec(ctx, addComment,
		arg.UserID,
		arg.BookGroupID,
		arg.BookChapterID,
		arg.Content,
	)
	return err
}

const checkIfCommentExist = `-- name: CheckIfCommentExist :one
SELECT EXISTS(select 1 from book_comments where id = $1)
`

func (q *Queries) CheckIfCommentExist(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfCommentExist, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countCommentInBookGroup = `-- name: CountCommentInBookGroup :one
SELECT COUNT(id)
FROM book_comments
WHERE book_group_id = $1
`

func (q *Queries) CountCommentInBookGroup(ctx context.Context, bookGroupID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countCommentInBookGroup, bookGroupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE
FROM book_comments
WHERE id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteComment, id)
	return err
}

const getBookChapterComments = `-- name: GetBookChapterComments :many
SELECT book_comments.id,
       book_comments.content,
       book_comments.posted_time,
       u.id   as userId,
       u.user_name,
       i.path as avatarPath,
       bc.id  as chapterId,
       bc.chapter_number
FROM book_comments
         JOIN users u on u.id = book_comments.user_id
         LEFT JOIN images i on u.avatar_image_id = i.id
         LEFT JOIN book_chapters bc on bc.id = book_comments.book_chapter_id
WHERE book_chapter_id = $1
ORDER BY posted_time desc
LIMIT 20 OFFSET $2
`

type GetBookChapterCommentsParams struct {
	BookChapterID sql.NullInt32 `json:"bookChapterID"`
	Offset        int32         `json:"offset"`
}

type GetBookChapterCommentsRow struct {
	ID            int32           `json:"id"`
	Content       string          `json:"content"`
	PostedTime    time.Time       `json:"postedTime"`
	Userid        int32           `json:"userid"`
	UserName      sql.NullString  `json:"userName"`
	Avatarpath    sql.NullString  `json:"avatarpath"`
	Chapterid     sql.NullInt32   `json:"chapterid"`
	ChapterNumber sql.NullFloat64 `json:"chapterNumber"`
}

func (q *Queries) GetBookChapterComments(ctx context.Context, arg GetBookChapterCommentsParams) ([]GetBookChapterCommentsRow, error) {
	rows, err := q.db.Query(ctx, getBookChapterComments, arg.BookChapterID, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookChapterCommentsRow
	for rows.Next() {
		var i GetBookChapterCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.PostedTime,
			&i.Userid,
			&i.UserName,
			&i.Avatarpath,
			&i.Chapterid,
			&i.ChapterNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookGroupAndChapterComments = `-- name: GetBookGroupAndChapterComments :many
SELECT book_comments.id,
       book_comments.content,
       book_comments.posted_time,
       u.id   as userId,
       u.user_name,
       i.path as avatarPath,
       bc.id  as chapterId,
       bc.chapter_number
FROM book_comments
         JOIN users u on u.id = book_comments.user_id
         LEFT JOIN images i on u.avatar_image_id = i.id
         LEFT JOIN book_chapters bc on bc.id = book_comments.book_chapter_id
WHERE book_comments.book_group_id = $1
  AND book_chapter_id = $2
ORDER BY posted_time desc
LIMIT 20 OFFSET $3
`

type GetBookGroupAndChapterCommentsParams struct {
	BookGroupID   int32         `json:"bookGroupID"`
	BookChapterID sql.NullInt32 `json:"bookChapterID"`
	Offset        int32         `json:"offset"`
}

type GetBookGroupAndChapterCommentsRow struct {
	ID            int32           `json:"id"`
	Content       string          `json:"content"`
	PostedTime    time.Time       `json:"postedTime"`
	Userid        int32           `json:"userid"`
	UserName      sql.NullString  `json:"userName"`
	Avatarpath    sql.NullString  `json:"avatarpath"`
	Chapterid     sql.NullInt32   `json:"chapterid"`
	ChapterNumber sql.NullFloat64 `json:"chapterNumber"`
}

func (q *Queries) GetBookGroupAndChapterComments(ctx context.Context, arg GetBookGroupAndChapterCommentsParams) ([]GetBookGroupAndChapterCommentsRow, error) {
	rows, err := q.db.Query(ctx, getBookGroupAndChapterComments, arg.BookGroupID, arg.BookChapterID, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookGroupAndChapterCommentsRow
	for rows.Next() {
		var i GetBookGroupAndChapterCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.PostedTime,
			&i.Userid,
			&i.UserName,
			&i.Avatarpath,
			&i.Chapterid,
			&i.ChapterNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookGroupComments = `-- name: GetBookGroupComments :many
SELECT book_comments.id,
       book_comments.content,
       book_comments.posted_time,
       u.id   as userId,
       u.user_name,
       i.path as avatarPath,
       bc.id  as chapterId,
       bc.chapter_number
FROM book_comments
         JOIN users u on u.id = book_comments.user_id
         LEFT JOIN images i on u.avatar_image_id = i.id
         LEFT JOIN book_chapters bc on bc.id = book_comments.book_chapter_id
WHERE book_comments.book_group_id = $1
ORDER BY posted_time desc
LIMIT 20 OFFSET $2
`

type GetBookGroupCommentsParams struct {
	BookGroupID int32 `json:"bookGroupID"`
	Offset      int32 `json:"offset"`
}

type GetBookGroupCommentsRow struct {
	ID            int32           `json:"id"`
	Content       string          `json:"content"`
	PostedTime    time.Time       `json:"postedTime"`
	Userid        int32           `json:"userid"`
	UserName      sql.NullString  `json:"userName"`
	Avatarpath    sql.NullString  `json:"avatarpath"`
	Chapterid     sql.NullInt32   `json:"chapterid"`
	ChapterNumber sql.NullFloat64 `json:"chapterNumber"`
}

func (q *Queries) GetBookGroupComments(ctx context.Context, arg GetBookGroupCommentsParams) ([]GetBookGroupCommentsRow, error) {
	rows, err := q.db.Query(ctx, getBookGroupComments, arg.BookGroupID, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookGroupCommentsRow
	for rows.Next() {
		var i GetBookGroupCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.PostedTime,
			&i.Userid,
			&i.UserName,
			&i.Avatarpath,
			&i.Chapterid,
			&i.ChapterNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentChapterInfo = `-- name: GetCommentChapterInfo :one
SELECT book_chapters.id, book_chapters.chapter_number
FROM book_chapters
         JOIN book_comments bc on book_chapters.id = bc.book_chapter_id
WHERE bc.id = $1
`

type GetCommentChapterInfoRow struct {
	ID            int32   `json:"id"`
	ChapterNumber float64 `json:"chapterNumber"`
}

func (q *Queries) GetCommentChapterInfo(ctx context.Context, id int32) (GetCommentChapterInfoRow, error) {
	row := q.db.QueryRow(ctx, getCommentChapterInfo, id)
	var i GetCommentChapterInfoRow
	err := row.Scan(&i.ID, &i.ChapterNumber)
	return i, err
}

const getCommenter = `-- name: GetCommenter :one
SELECT users.id, users.user_name, i.path
FROM users
         JOIN book_comments bc on users.id = bc.user_id
         LEFT JOIN images i on users.avatar_image_id = i.id
WHERE bc.id = $1
`

type GetCommenterRow struct {
	ID       int32          `json:"id"`
	UserName sql.NullString `json:"userName"`
	Path     sql.NullString `json:"path"`
}

func (q *Queries) GetCommenter(ctx context.Context, id int32) (GetCommenterRow, error) {
	row := q.db.QueryRow(ctx, getCommenter, id)
	var i GetCommenterRow
	err := row.Scan(&i.ID, &i.UserName, &i.Path)
	return i, err
}

const getLatestComments = `-- name: GetLatestComments :many
SELECT book_comments.id,
       book_comments.content,
       book_comments.posted_time,
       u.id   as userId,
       u.user_name,
       i.path as avatarPath,
       bc.id  as chapterId,
       bc.name as chapterName,
       bc.chapter_number,
       bg.id as bookId,
       bg.title as bookName
FROM book_comments
         JOIN users u on u.id = book_comments.user_id
         JOIN book_groups bg on book_comments.book_group_id = bg.id
         LEFT JOIN images i on u.avatar_image_id = i.id
         LEFT JOIN book_chapters bc on bc.id = book_comments.book_chapter_id
ORDER BY posted_time DESC
LIMIT 15
`

type GetLatestCommentsRow struct {
	ID            int32           `json:"id"`
	Content       string          `json:"content"`
	PostedTime    time.Time       `json:"postedTime"`
	Userid        int32           `json:"userid"`
	UserName      sql.NullString  `json:"userName"`
	Avatarpath    sql.NullString  `json:"avatarpath"`
	Chapterid     sql.NullInt32   `json:"chapterid"`
	Chaptername   sql.NullString  `json:"chaptername"`
	ChapterNumber sql.NullFloat64 `json:"chapterNumber"`
	Bookid        int32           `json:"bookid"`
	Bookname      string          `json:"bookname"`
}

func (q *Queries) GetLatestComments(ctx context.Context) ([]GetLatestCommentsRow, error) {
	rows, err := q.db.Query(ctx, getLatestComments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestCommentsRow
	for rows.Next() {
		var i GetLatestCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Content,
			&i.PostedTime,
			&i.Userid,
			&i.UserName,
			&i.Avatarpath,
			&i.Chapterid,
			&i.Chaptername,
			&i.ChapterNumber,
			&i.Bookid,
			&i.Bookname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalBookChapterComments = `-- name: GetTotalBookChapterComments :one
SELECT count(*)
FROM book_comments
WHERE book_chapter_id = $1
`

func (q *Queries) GetTotalBookChapterComments(ctx context.Context, bookChapterID sql.NullInt32) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalBookChapterComments, bookChapterID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalBookGroupAndChapterComments = `-- name: GetTotalBookGroupAndChapterComments :one
SELECT count(*)
FROM book_comments
WHERE book_group_id = $1
  AND book_chapter_id = $2
`

type GetTotalBookGroupAndChapterCommentsParams struct {
	BookGroupID   int32         `json:"bookGroupID"`
	BookChapterID sql.NullInt32 `json:"bookChapterID"`
}

func (q *Queries) GetTotalBookGroupAndChapterComments(ctx context.Context, arg GetTotalBookGroupAndChapterCommentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalBookGroupAndChapterComments, arg.BookGroupID, arg.BookChapterID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTotalBookGroupComments = `-- name: GetTotalBookGroupComments :one
SELECT count(*)
FROM book_comments
WHERE book_group_id = $1
`

func (q *Queries) GetTotalBookGroupComments(ctx context.Context, bookGroupID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalBookGroupComments, bookGroupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateComment = `-- name: UpdateComment :exec
UPDATE book_comments
SET content = $2
WHERE id = $1
`

type UpdateCommentParams struct {
	ID      int32  `json:"id"`
	Content string `json:"content"`
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) error {
	_, err := q.db.Exec(ctx, updateComment, arg.ID, arg.Content)
	return err
}
