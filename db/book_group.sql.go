// Code generated by sqlc. DO NOT EDIT.
// source: book_group.sql

package db

import (
	"context"
	"database/sql"
)

const bookGroupById = `-- name: BookGroupById :one
SELECT id, title, aliases, description, date_created, owner_id, primary_cover_art_id
FROM book_groups
WHERE id = $1
`

type BookGroupByIdRow struct {
	ID                int32          `json:"id"`
	Title             string         `json:"title"`
	Aliases           sql.NullString `json:"aliases"`
	Description       sql.NullString `json:"description"`
	DateCreated       sql.NullTime   `json:"dateCreated"`
	OwnerID           int32          `json:"ownerID"`
	PrimaryCoverArtID sql.NullInt32  `json:"primaryCoverArtID"`
}

func (q *Queries) BookGroupById(ctx context.Context, id int32) (BookGroupByIdRow, error) {
	row := q.db.QueryRow(ctx, bookGroupById, id)
	var i BookGroupByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Aliases,
		&i.Description,
		&i.DateCreated,
		&i.OwnerID,
		&i.PrimaryCoverArtID,
	)
	return i, err
}

const bookGroupsByTitle = `-- name: BookGroupsByTitle :many
SELECT id, title, aliases, description, date_created, owner_id, primary_cover_art_id
FROM book_groups
WHERE book_group_tsv @@ to_tsquery(unaccent($1))
ORDER BY id
OFFSET $2 ROWS
    FETCH FIRST $3 ROWS ONLY
`

type BookGroupsByTitleParams struct {
	Unaccent string `json:"unaccent"`
	Offset   int32  `json:"offset"`
	Limit    int32  `json:"limit"`
}

type BookGroupsByTitleRow struct {
	ID                int32          `json:"id"`
	Title             string         `json:"title"`
	Aliases           sql.NullString `json:"aliases"`
	Description       sql.NullString `json:"description"`
	DateCreated       sql.NullTime   `json:"dateCreated"`
	OwnerID           int32          `json:"ownerID"`
	PrimaryCoverArtID sql.NullInt32  `json:"primaryCoverArtID"`
}

func (q *Queries) BookGroupsByTitle(ctx context.Context, arg BookGroupsByTitleParams) ([]BookGroupsByTitleRow, error) {
	rows, err := q.db.Query(ctx, bookGroupsByTitle, arg.Unaccent, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookGroupsByTitleRow
	for rows.Next() {
		var i BookGroupsByTitleRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Aliases,
			&i.Description,
			&i.DateCreated,
			&i.OwnerID,
			&i.PrimaryCoverArtID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bookGroupsTopViewAll = `-- name: BookGroupsTopViewAll :many
SELECT bg.id id,
       (array_agg(i.path))[1] AS image,
       bg.title AS title,
       bct.latest_chapter,
       bct.last_updated,
       bct.views,
       bcm.comments,
       bgl.likes
FROM book_groups AS bg
         LEFT JOIN Lateral (
    SELECT count(bcm.id) AS comments
    FROM book_comments bcm
    WHERE bcm.book_group_id = bg.id
    ) bcm ON TRUE
         LEFT JOIN Lateral (
    SELECT coalesce(sum(bgl.point), 0) AS likes
    FROM book_group_likes bgl
    WHERE bgl.book_group_id = bg.id
    ) bgl ON TRUE
         LEFT JOIN LATERAL (
    SELECT (array_agg(bct.chapter_number ORDER BY bct.date_created DESC))[1] AS latest_chapter,
           MAX(bct.date_created) AS last_updated,
           coalesce(sum(bcv.count),0) AS views
    FROM book_chapters bct
             LEFT JOIN book_chapter_views bcv
                       ON bct.id = bcv.book_chapter_id
    WHERE bct.book_group_id = bg.id
    ) bct ON TRUE
         LEFT JOIN images i ON bg.primary_cover_art_id = i.id
GROUP BY bg.id, bg.title, i.path, bct.latest_chapter, bct.last_updated, bct.views, bcm.comments, bgl.likes
ORDER BY bct.views DESC
LIMIT $1
`

type BookGroupsTopViewAllRow struct {
	ID            int32       `json:"id"`
	Image         interface{} `json:"image"`
	Title         string      `json:"title"`
	LatestChapter interface{} `json:"latestChapter"`
	LastUpdated   interface{} `json:"lastUpdated"`
	Views         interface{} `json:"views"`
	Comments      int64       `json:"comments"`
	Likes         interface{} `json:"likes"`
}

func (q *Queries) BookGroupsTopViewAll(ctx context.Context, limit int32) ([]BookGroupsTopViewAllRow, error) {
	rows, err := q.db.Query(ctx, bookGroupsTopViewAll, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookGroupsTopViewAllRow
	for rows.Next() {
		var i BookGroupsTopViewAllRow
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Title,
			&i.LatestChapter,
			&i.LastUpdated,
			&i.Views,
			&i.Comments,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bookGroupsTopViewMonth = `-- name: BookGroupsTopViewMonth :many
SELECT bg.id id,
       (array_agg(i.path))[1] AS image,
       bg.title AS title,
       bct.latest_chapter,
       bct.last_updated,
       bct.views,
       bcm.comments,
       bgl.likes
FROM book_groups AS bg
         LEFT JOIN Lateral (
    SELECT count(bcm.id) AS comments
    FROM book_comments bcm
    WHERE bcm.book_group_id = bg.id
    ) bcm ON TRUE
         LEFT JOIN Lateral (
    SELECT coalesce(sum(bgl.point), 0) AS likes
    FROM book_group_likes bgl
    WHERE bgl.book_group_id = bg.id
    ) bgl ON TRUE
         LEFT JOIN LATERAL (
    SELECT (array_agg(bct.chapter_number ORDER BY bct.date_created DESC))[1] AS latest_chapter,
           MAX(bct.date_created) AS last_updated,
           coalesce(sum(bcv.count),0) AS views
    FROM book_chapters bct
             LEFT JOIN book_chapter_views bcv
                       ON bct.id = bcv.book_chapter_id
                           AND bcv.view_date>= (now()-Interval '1 month')
    WHERE bct.book_group_id = bg.id
    ) bct ON TRUE
         LEFT JOIN images i ON bg.primary_cover_art_id = i.id
GROUP BY bg.id, bg.title, i.path, bct.latest_chapter, bct.last_updated, bct.views, bcm.comments, bgl.likes
ORDER BY bct.views DESC
LIMIT $1
`

type BookGroupsTopViewMonthRow struct {
	ID            int32       `json:"id"`
	Image         interface{} `json:"image"`
	Title         string      `json:"title"`
	LatestChapter interface{} `json:"latestChapter"`
	LastUpdated   interface{} `json:"lastUpdated"`
	Views         interface{} `json:"views"`
	Comments      int64       `json:"comments"`
	Likes         interface{} `json:"likes"`
}

func (q *Queries) BookGroupsTopViewMonth(ctx context.Context, limit int32) ([]BookGroupsTopViewMonthRow, error) {
	rows, err := q.db.Query(ctx, bookGroupsTopViewMonth, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookGroupsTopViewMonthRow
	for rows.Next() {
		var i BookGroupsTopViewMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Title,
			&i.LatestChapter,
			&i.LastUpdated,
			&i.Views,
			&i.Comments,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bookGroupsTopViewWeek = `-- name: BookGroupsTopViewWeek :many
SELECT bg.id id,
       (array_agg(i.path))[1] AS image,
       bg.title AS title,
       bct.latest_chapter,
       bct.last_updated,
       bct.views,
       bcm.comments,
       bgl.likes
FROM book_groups AS bg
LEFT JOIN Lateral (
    SELECT count(bcm.id) AS comments
    FROM book_comments bcm
    WHERE bcm.book_group_id = bg.id
    ) bcm ON TRUE
LEFT JOIN Lateral (
    SELECT coalesce(sum(bgl.point), 0) AS likes
    FROM book_group_likes bgl
    WHERE bgl.book_group_id = bg.id
    ) bgl ON TRUE
LEFT JOIN LATERAL (
    SELECT (array_agg(bct.chapter_number ORDER BY bct.date_created DESC))[1] AS latest_chapter,
           MAX(bct.date_created) AS last_updated,
           coalesce(sum(bcv.count),0) AS views
    FROM book_chapters bct
        LEFT JOIN book_chapter_views bcv
        ON bct.id = bcv.book_chapter_id
        AND bcv.view_date>= (now()-Interval '1 week')
    WHERE bct.book_group_id = bg.id
    ) bct ON TRUE
LEFT JOIN images i ON bg.primary_cover_art_id = i.id
GROUP BY bg.id, bg.title, i.path, bct.latest_chapter, bct.last_updated, bct.views, bcm.comments, bgl.likes
ORDER BY bct.views DESC
LIMIT $1
`

type BookGroupsTopViewWeekRow struct {
	ID            int32       `json:"id"`
	Image         interface{} `json:"image"`
	Title         string      `json:"title"`
	LatestChapter interface{} `json:"latestChapter"`
	LastUpdated   interface{} `json:"lastUpdated"`
	Views         interface{} `json:"views"`
	Comments      int64       `json:"comments"`
	Likes         interface{} `json:"likes"`
}

func (q *Queries) BookGroupsTopViewWeek(ctx context.Context, limit int32) ([]BookGroupsTopViewWeekRow, error) {
	rows, err := q.db.Query(ctx, bookGroupsTopViewWeek, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookGroupsTopViewWeekRow
	for rows.Next() {
		var i BookGroupsTopViewWeekRow
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Title,
			&i.LatestChapter,
			&i.LastUpdated,
			&i.Views,
			&i.Comments,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bookGroupsTopViewYear = `-- name: BookGroupsTopViewYear :many
SELECT bg.id id,
       (array_agg(i.path))[1] AS image,
       bg.title AS title,
       bct.latest_chapter,
       bct.last_updated,
       bct.views,
       bcm.comments,
       bgl.likes
FROM book_groups AS bg
         LEFT JOIN Lateral (
    SELECT count(bcm.id) AS comments
    FROM book_comments bcm
    WHERE bcm.book_group_id = bg.id
    ) bcm ON TRUE
         LEFT JOIN Lateral (
    SELECT coalesce(sum(bgl.point), 0) AS likes
    FROM book_group_likes bgl
    WHERE bgl.book_group_id = bg.id
    ) bgl ON TRUE
         LEFT JOIN LATERAL (
    SELECT (array_agg(bct.chapter_number ORDER BY bct.date_created DESC))[1] AS latest_chapter,
           MAX(bct.date_created) AS last_updated,
           coalesce(sum(bcv.count),0) AS views
    FROM book_chapters bct
             LEFT JOIN book_chapter_views bcv
                       ON bct.id = bcv.book_chapter_id
                           AND bcv.view_date>= (now()-Interval '1 year')
    WHERE bct.book_group_id = bg.id
    ) bct ON TRUE
         LEFT JOIN images i ON bg.primary_cover_art_id = i.id
GROUP BY bg.id, bg.title, i.path, bct.latest_chapter, bct.last_updated, bct.views, bcm.comments, bgl.likes
ORDER BY bct.views DESC
LIMIT $1
`

type BookGroupsTopViewYearRow struct {
	ID            int32       `json:"id"`
	Image         interface{} `json:"image"`
	Title         string      `json:"title"`
	LatestChapter interface{} `json:"latestChapter"`
	LastUpdated   interface{} `json:"lastUpdated"`
	Views         interface{} `json:"views"`
	Comments      int64       `json:"comments"`
	Likes         interface{} `json:"likes"`
}

func (q *Queries) BookGroupsTopViewYear(ctx context.Context, limit int32) ([]BookGroupsTopViewYearRow, error) {
	rows, err := q.db.Query(ctx, bookGroupsTopViewYear, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookGroupsTopViewYearRow
	for rows.Next() {
		var i BookGroupsTopViewYearRow
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Title,
			&i.LatestChapter,
			&i.LastUpdated,
			&i.Views,
			&i.Comments,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkBookGroupById = `-- name: CheckBookGroupById :one
SELECT EXISTS(SElECT 1 FROM book_groups WHERE id = $1)
`

func (q *Queries) CheckBookGroupById(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkBookGroupById, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteBookGroup = `-- name: DeleteBookGroup :exec
DELETE FROM book_groups
WHERE id = $1
`

func (q *Queries) DeleteBookGroup(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBookGroup, id)
	return err
}

const insertBookGroup = `-- name: InsertBookGroup :one
INSERT INTO book_groups(title, aliases, description,owner_id,primary_cover_art_id)
VALUES ($1, $2, $3,$4,$5)
RETURNING id, title, aliases, description, date_created, owner_id, primary_cover_art_id
`

type InsertBookGroupParams struct {
	Title             string         `json:"title"`
	Aliases           sql.NullString `json:"aliases"`
	Description       sql.NullString `json:"description"`
	OwnerID           int32          `json:"ownerID"`
	PrimaryCoverArtID sql.NullInt32  `json:"primaryCoverArtID"`
}

type InsertBookGroupRow struct {
	ID                int32          `json:"id"`
	Title             string         `json:"title"`
	Aliases           sql.NullString `json:"aliases"`
	Description       sql.NullString `json:"description"`
	DateCreated       sql.NullTime   `json:"dateCreated"`
	OwnerID           int32          `json:"ownerID"`
	PrimaryCoverArtID sql.NullInt32  `json:"primaryCoverArtID"`
}

func (q *Queries) InsertBookGroup(ctx context.Context, arg InsertBookGroupParams) (InsertBookGroupRow, error) {
	row := q.db.QueryRow(ctx, insertBookGroup,
		arg.Title,
		arg.Aliases,
		arg.Description,
		arg.OwnerID,
		arg.PrimaryCoverArtID,
	)
	var i InsertBookGroupRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Aliases,
		&i.Description,
		&i.DateCreated,
		&i.OwnerID,
		&i.PrimaryCoverArtID,
	)
	return i, err
}

const latestBookGroups = `-- name: LatestBookGroups :many
SELECT bg.id id,
       (array_agg(i.path))[1] AS image,
       bg.title AS title,
       bct.latest_chapter,
       bct.last_updated,
       bct.views,
       bcm.comments,
       bgl.likes
FROM book_groups AS bg
         LEFT JOIN Lateral (
    SELECT count(bcm.id) AS comments
    FROM book_comments bcm
    WHERE bcm.book_group_id = bg.id
    ) bcm ON TRUE
         LEFT JOIN Lateral (
    SELECT coalesce(sum(bgl.point), 0) AS likes
    FROM book_group_likes bgl
    WHERE bgl.book_group_id = bg.id
    ) bgl ON TRUE
         LEFT JOIN LATERAL (
    SELECT (array_agg(bct.chapter_number ORDER BY bct.date_created DESC))[1] AS latest_chapter,
           MAX(bct.date_created) AS last_updated,
           coalesce(sum(bcv.count),0) AS views
    FROM book_chapters bct
             LEFT JOIN book_chapter_views bcv
                       ON bct.id = bcv.book_chapter_id
    WHERE bct.book_group_id = bg.id
    ) bct ON TRUE
         LEFT JOIN images i ON bg.primary_cover_art_id = i.id
GROUP BY bg.id, bg.title, i.path, bct.latest_chapter, bct.last_updated, bct.views, bcm.comments, bgl.likes
ORDER BY last_updated DESC  NULLS LAST
OFFSET $1 ROWS FETCH FIRST $2 ROWS ONLY
`

type LatestBookGroupsParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

type LatestBookGroupsRow struct {
	ID            int32       `json:"id"`
	Image         interface{} `json:"image"`
	Title         string      `json:"title"`
	LatestChapter interface{} `json:"latestChapter"`
	LastUpdated   interface{} `json:"lastUpdated"`
	Views         interface{} `json:"views"`
	Comments      int64       `json:"comments"`
	Likes         interface{} `json:"likes"`
}

func (q *Queries) LatestBookGroups(ctx context.Context, arg LatestBookGroupsParams) ([]LatestBookGroupsRow, error) {
	rows, err := q.db.Query(ctx, latestBookGroups, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LatestBookGroupsRow
	for rows.Next() {
		var i LatestBookGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Title,
			&i.LatestChapter,
			&i.LastUpdated,
			&i.Views,
			&i.Comments,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const numberBookGroup = `-- name: NumberBookGroup :one
SELECT COUNT(id)
FROM book_groups
`

func (q *Queries) NumberBookGroup(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, numberBookGroup)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const numberBookGroupSearchResult = `-- name: NumberBookGroupSearchResult :one
SELECT COUNT(id)
FROM book_groups
WHERE book_group_tsv @@ to_tsquery(unaccent($1))
`

func (q *Queries) NumberBookGroupSearchResult(ctx context.Context, query string) (int64, error) {
	row := q.db.QueryRow(ctx, numberBookGroupSearchResult, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const randomBookGroups = `-- name: RandomBookGroups :many
SELECT bg.id id,
       (array_agg(i.path))[1] AS image,
       bg.title AS title,
       bct.latest_chapter,
       bct.last_updated,
       bct.views,
       bcm.comments,
       bgl.likes
FROM book_groups AS bg
         LEFT JOIN Lateral (
    SELECT count(bcm.id) AS comments
    FROM book_comments bcm
    WHERE bcm.book_group_id = bg.id
    ) bcm ON TRUE
         LEFT JOIN Lateral (
    SELECT coalesce(sum(bgl.point), 0) AS likes
    FROM book_group_likes bgl
    WHERE bgl.book_group_id = bg.id
    ) bgl ON TRUE
         LEFT JOIN LATERAL (
    SELECT (array_agg(bct.chapter_number ORDER BY bct.date_created DESC))[1] AS latest_chapter,
           MAX(bct.date_created) AS last_updated,
           coalesce(sum(bcv.count),0) AS views
    FROM book_chapters bct
             LEFT JOIN book_chapter_views bcv
                       ON bct.id = bcv.book_chapter_id
    WHERE bct.book_group_id = bg.id
    ) bct ON TRUE
         LEFT JOIN images i ON bg.primary_cover_art_id = i.id
GROUP BY bg.id, bg.title, i.path, bct.latest_chapter, bct.last_updated, bct.views, bcm.comments, bgl.likes
ORDER BY RANDOM() LIMIT $1
`

type RandomBookGroupsRow struct {
	ID            int32       `json:"id"`
	Image         interface{} `json:"image"`
	Title         string      `json:"title"`
	LatestChapter interface{} `json:"latestChapter"`
	LastUpdated   interface{} `json:"lastUpdated"`
	Views         interface{} `json:"views"`
	Comments      int64       `json:"comments"`
	Likes         interface{} `json:"likes"`
}

func (q *Queries) RandomBookGroups(ctx context.Context, limit int32) ([]RandomBookGroupsRow, error) {
	rows, err := q.db.Query(ctx, randomBookGroups, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RandomBookGroupsRow
	for rows.Next() {
		var i RandomBookGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Title,
			&i.LatestChapter,
			&i.LastUpdated,
			&i.Views,
			&i.Comments,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchResult = `-- name: SearchResult :many
SELECT bg.id id,
       (array_agg(i.path))[1] AS image,
       bg.title AS title,
       bct.latest_chapter,
       bct.last_updated,
       bct.views,
       bcm.comments,
       bgl.likes
FROM book_groups AS bg
         LEFT JOIN Lateral (
    SELECT count(bcm.id) AS comments
    FROM book_comments bcm
    WHERE bcm.book_group_id = bg.id
    ) bcm ON TRUE
         LEFT JOIN Lateral (
    SELECT coalesce(sum(bgl.point), 0) AS likes
    FROM book_group_likes bgl
    WHERE bgl.book_group_id = bg.id
    ) bgl ON TRUE
         LEFT JOIN LATERAL (
    SELECT (array_agg(bct.chapter_number ORDER BY bct.date_created DESC))[1] AS latest_chapter,
           MAX(bct.date_created) AS last_updated,
           coalesce(sum(bcv.count),0) AS views
    FROM book_chapters bct
             LEFT JOIN book_chapter_views bcv
                       ON bct.id = bcv.book_chapter_id
    WHERE bct.book_group_id = bg.id
    ) bct ON TRUE
         LEFT JOIN images i ON bg.primary_cover_art_id = i.id
WHERE bg.book_group_tsv @@ to_tsquery(unaccent($3))
GROUP BY bg.id, bg.title, i.path, bct.latest_chapter, bct.last_updated, bct.views, bcm.comments, bgl.likes
ORDER BY last_updated DESC  NULLS LAST
OFFSET $1 ROWS FETCH FIRST $2 ROWS ONLY
`

type SearchResultParams struct {
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
	Query  string `json:"query"`
}

type SearchResultRow struct {
	ID            int32       `json:"id"`
	Image         interface{} `json:"image"`
	Title         string      `json:"title"`
	LatestChapter interface{} `json:"latestChapter"`
	LastUpdated   interface{} `json:"lastUpdated"`
	Views         interface{} `json:"views"`
	Comments      int64       `json:"comments"`
	Likes         interface{} `json:"likes"`
}

func (q *Queries) SearchResult(ctx context.Context, arg SearchResultParams) ([]SearchResultRow, error) {
	rows, err := q.db.Query(ctx, searchResult, arg.Offset, arg.Limit, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchResultRow
	for rows.Next() {
		var i SearchResultRow
		if err := rows.Scan(
			&i.ID,
			&i.Image,
			&i.Title,
			&i.LatestChapter,
			&i.LastUpdated,
			&i.Views,
			&i.Comments,
			&i.Likes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSuggestion = `-- name: SearchSuggestion :many
SELECT bg.title AS title,
       bg.id AS id,
       (array_agg(i.path))[1] AS image,
       (array_agg(bct.chapter_number ORDER BY bct.date_created DESC))[1] AS latest_chapter
FROM book_groups AS bg
         LEFT JOIN images i on bg.primary_cover_art_id = i.id
         LEFT JOIN book_chapters bct on bg.id = bct.book_group_id
WHERE bg.book_group_tsv @@ to_tsquery(unaccent($1))
GROUP BY bg.id
LIMIT 5
`

type SearchSuggestionRow struct {
	Title         string      `json:"title"`
	ID            int32       `json:"id"`
	Image         interface{} `json:"image"`
	LatestChapter interface{} `json:"latestChapter"`
}

func (q *Queries) SearchSuggestion(ctx context.Context, query string) ([]SearchSuggestionRow, error) {
	rows, err := q.db.Query(ctx, searchSuggestion, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSuggestionRow
	for rows.Next() {
		var i SearchSuggestionRow
		if err := rows.Scan(
			&i.Title,
			&i.ID,
			&i.Image,
			&i.LatestChapter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookGroup = `-- name: UpdateBookGroup :exec
UPDATE book_groups
SET title = $2,
    description=$3,
    primary_cover_art_id=$4,
    aliases = $5
WHERE id = $1
`

type UpdateBookGroupParams struct {
	ID                int32          `json:"id"`
	Title             string         `json:"title"`
	Description       sql.NullString `json:"description"`
	PrimaryCoverArtID sql.NullInt32  `json:"primaryCoverArtID"`
	Aliases           sql.NullString `json:"aliases"`
}

func (q *Queries) UpdateBookGroup(ctx context.Context, arg UpdateBookGroupParams) error {
	_, err := q.db.Exec(ctx, updateBookGroup,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.PrimaryCoverArtID,
		arg.Aliases,
	)
	return err
}
